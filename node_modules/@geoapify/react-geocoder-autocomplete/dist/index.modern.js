import React, { useRef, useEffect } from 'react';
import { GeocoderAutocomplete } from '@geoapify/geocoder-autocomplete';

var GeoapifyApiKey = React.createContext('');
var GeoapifyContext = function GeoapifyContext(props) {
  return React.createElement(GeoapifyApiKey.Provider, {
    value: props.apiKey
  }, props.children);
};
var GeoapifyGeocoderAutocomplete = function GeoapifyGeocoderAutocomplete(_ref) {
  var placeholderValue = _ref.placeholder,
    typeValue = _ref.type,
    langValue = _ref.lang,
    limitValue = _ref.limit,
    valueValue = _ref.value,
    filterByCountryCodeValue = _ref.filterByCountryCode,
    filterByCircleValue = _ref.filterByCircle,
    filterByRectValue = _ref.filterByRect,
    filterByPlaceValue = _ref.filterByPlace,
    biasByCountryCodeValue = _ref.biasByCountryCode,
    biasByCircleValue = _ref.biasByCircle,
    biasByRectValue = _ref.biasByRect,
    biasByProximityValue = _ref.biasByProximity,
    positionValue = _ref.position,
    countryCodesValue = _ref.countryCodes,
    debounceDelayValue = _ref.debounceDelay,
    skipIconsValue = _ref.skipIcons,
    skipSelectionOnArrowKeyValue = _ref.skipSelectionOnArrowKey,
    allowNonVerifiedHouseNumberValue = _ref.allowNonVerifiedHouseNumber,
    allowNonVerifiedStreetValue = _ref.allowNonVerifiedStreet,
    addDetailsValue = _ref.addDetails,
    addCategorySearchValue = _ref.addCategorySearch,
    showPlacesByCategoryListValue = _ref.showPlacesByCategoryList,
    hidePlacesByCategoryListAfterSelectValue = _ref.hidePlacesByCategoryListAfterSelect,
    enablePlacesByCategoryLazyLoadingValue = _ref.enablePlacesByCategoryLazyLoading,
    placesByCategoryLimitValue = _ref.placesByCategoryLimit,
    placesByCategoryFilterValue = _ref.placesByCategoryFilter,
    placesByCategoryBiasValue = _ref.placesByCategoryBias,
    sendPlacesByCategoryRequestFuncValue = _ref.sendPlacesByCategoryRequestFunc,
    preprocessHookValue = _ref.preprocessHook,
    postprocessHookValue = _ref.postprocessHook,
    suggestionsFilterValue = _ref.suggestionsFilter,
    sendGeocoderRequestFuncValue = _ref.sendGeocoderRequestFunc,
    sendPlaceDetailsRequestFuncValue = _ref.sendPlaceDetailsRequestFunc,
    placeSelectCallback = _ref.placeSelect,
    suggestionsChangeCallback = _ref.suggestionsChange,
    userInputCallback = _ref.onUserInput,
    openCallback = _ref.onOpen,
    closeCallback = _ref.onClose,
    requestStartCallback = _ref.onRequestStart,
    requestEndCallback = _ref.onRequestEnd,
    placesByCategoryChangeCallback = _ref.onPlacesByCategoryChange,
    placesByCategoryRequestStartCallback = _ref.onPlacesByCategoryRequestStart,
    placesByCategoryRequestEndCallback = _ref.onPlacesByCategoryRequestEnd,
    placeDetailsRequestStartCallback = _ref.onPlaceDetailsRequestStart,
    placeDetailsRequestEndCallback = _ref.onPlaceDetailsRequestEnd,
    placeByCategorySelectCallback = _ref.onPlaceByCategorySelect,
    clearCallback = _ref.onClear;
  var apiKey = React.useContext(GeoapifyApiKey);
  var geocoderContainer;
  var geocoderAutocomplete = useRef(undefined);
  var placeSelectCallbackRef = useRef(undefined);
  var suggestionsChangeCallbackRef = useRef(undefined);
  var userInputCallbackRef = useRef(undefined);
  var openCallbackRef = useRef(undefined);
  var closeCallbackRef = useRef(undefined);
  var requestStartCallbackRef = useRef(undefined);
  var requestEndCallbackRef = useRef(undefined);
  var placesByCategoryChangeCallbackRef = useRef(undefined);
  var placesByCategoryRequestStartCallbackRef = useRef(undefined);
  var placesByCategoryRequestEndCallbackRef = useRef(undefined);
  var placeDetailsRequestStartCallbackRef = useRef(undefined);
  var placeDetailsRequestEndCallbackRef = useRef(undefined);
  var placeByCategorySelectCallbackRef = useRef(undefined);
  var clearCallbackRef = useRef(undefined);
  placeSelectCallbackRef.current = placeSelectCallback;
  suggestionsChangeCallbackRef.current = suggestionsChangeCallback;
  userInputCallbackRef.current = userInputCallback;
  openCallbackRef.current = openCallback;
  closeCallbackRef.current = closeCallback;
  requestStartCallbackRef.current = requestStartCallback;
  requestEndCallbackRef.current = requestEndCallback;
  placesByCategoryChangeCallbackRef.current = placesByCategoryChangeCallback;
  placesByCategoryRequestStartCallbackRef.current = placesByCategoryRequestStartCallback;
  placesByCategoryRequestEndCallbackRef.current = placesByCategoryRequestEndCallback;
  placeDetailsRequestStartCallbackRef.current = placeDetailsRequestStartCallback;
  placeDetailsRequestEndCallbackRef.current = placeDetailsRequestEndCallback;
  placeByCategorySelectCallbackRef.current = placeByCategorySelectCallback;
  clearCallbackRef.current = clearCallback;
  var onSelect = React.useCallback(function (value) {
    if (placeSelectCallbackRef.current) {
      placeSelectCallbackRef.current(value);
    }
  }, []);
  var onSuggestions = React.useCallback(function (value) {
    if (suggestionsChangeCallbackRef.current) {
      suggestionsChangeCallbackRef.current(value);
    }
  }, []);
  var onUserInput = React.useCallback(function (input) {
    if (userInputCallbackRef.current) {
      userInputCallbackRef.current(input);
    }
  }, []);
  var onOpen = React.useCallback(function (opened) {
    if (openCallbackRef.current) {
      openCallbackRef.current(opened);
    }
  }, []);
  var onClose = React.useCallback(function (opened) {
    if (closeCallbackRef.current) {
      closeCallbackRef.current(opened);
    }
  }, []);
  var onRequestStart = React.useCallback(function (value) {
    if (requestStartCallbackRef.current) {
      requestStartCallbackRef.current(value);
    }
  }, []);
  var onRequestEnd = React.useCallback(function (success, data, error) {
    if (requestEndCallbackRef.current) {
      requestEndCallbackRef.current(success, data, error);
    }
  }, []);
  var onPlacesByCategoryChange = React.useCallback(function (places) {
    if (placesByCategoryChangeCallbackRef.current) {
      placesByCategoryChangeCallbackRef.current(places);
    }
  }, []);
  var onPlacesByCategoryRequestStart = React.useCallback(function (category) {
    if (placesByCategoryRequestStartCallbackRef.current) {
      placesByCategoryRequestStartCallbackRef.current(category);
    }
  }, []);
  var onPlacesByCategoryRequestEnd = React.useCallback(function (success, data, error) {
    if (placesByCategoryRequestEndCallbackRef.current) {
      placesByCategoryRequestEndCallbackRef.current(success, data, error);
    }
  }, []);
  var onPlaceDetailsRequestStart = React.useCallback(function (feature) {
    if (placeDetailsRequestStartCallbackRef.current) {
      placeDetailsRequestStartCallbackRef.current(feature);
    }
  }, []);
  var onPlaceDetailsRequestEnd = React.useCallback(function (success, data, error) {
    if (placeDetailsRequestEndCallbackRef.current) {
      placeDetailsRequestEndCallbackRef.current(success, data, error);
    }
  }, []);
  var onPlaceByCategorySelect = React.useCallback(function (value) {
    if (placeByCategorySelectCallbackRef.current) {
      placeByCategorySelectCallbackRef.current(value);
    }
  }, []);
  var onClear = React.useCallback(function (type) {
    if (clearCallbackRef.current) {
      clearCallbackRef.current(type);
    }
  }, []);
  useEffect(function () {
    if (!geocoderAutocomplete.current) {
      geocoderAutocomplete.current = new GeocoderAutocomplete(geocoderContainer, apiKey, {
        placeholder: placeholderValue || "",
        addDetails: addDetailsValue,
        skipIcons: skipIconsValue,
        skipSelectionOnArrowKey: skipSelectionOnArrowKeyValue,
        allowNonVerifiedHouseNumber: allowNonVerifiedHouseNumberValue,
        allowNonVerifiedStreet: allowNonVerifiedStreetValue,
        debounceDelay: debounceDelayValue || 100,
        addCategorySearch: addCategorySearchValue,
        showPlacesList: showPlacesByCategoryListValue,
        hidePlacesListAfterSelect: hidePlacesByCategoryListAfterSelectValue,
        enablePlacesLazyLoading: enablePlacesByCategoryLazyLoadingValue,
        placesLimit: placesByCategoryLimitValue,
        placesFilter: placesByCategoryFilterValue,
        placesBias: placesByCategoryBiasValue
      });
    }
    geocoderAutocomplete.current.on("select", onSelect);
    geocoderAutocomplete.current.on("suggestions", onSuggestions);
    geocoderAutocomplete.current.on("input", onUserInput);
    geocoderAutocomplete.current.on("close", onClose);
    geocoderAutocomplete.current.on("open", onOpen);
    geocoderAutocomplete.current.on("request_start", onRequestStart);
    geocoderAutocomplete.current.on("request_end", onRequestEnd);
    geocoderAutocomplete.current.on("places", onPlacesByCategoryChange);
    geocoderAutocomplete.current.on("places_request_start", onPlacesByCategoryRequestStart);
    geocoderAutocomplete.current.on("places_request_end", onPlacesByCategoryRequestEnd);
    geocoderAutocomplete.current.on("place_details_request_start", onPlaceDetailsRequestStart);
    geocoderAutocomplete.current.on("place_details_request_end", onPlaceDetailsRequestEnd);
    geocoderAutocomplete.current.on("place_select", onPlaceByCategorySelect);
    geocoderAutocomplete.current.on("clear", onClear);
    if (sendGeocoderRequestFuncValue) {
      geocoderAutocomplete.current.setSendGeocoderRequestFunc(sendGeocoderRequestFuncValue);
    }
    if (sendPlacesByCategoryRequestFuncValue) {
      geocoderAutocomplete.current.setSendPlacesRequestFunc(sendPlacesByCategoryRequestFuncValue);
    }
    return function () {
      if (geocoderAutocomplete.current) {
        geocoderAutocomplete.current.off("select", onSelect);
        geocoderAutocomplete.current.off("suggestions", onSuggestions);
        geocoderAutocomplete.current.off("input", onUserInput);
        geocoderAutocomplete.current.off("close", onClose);
        geocoderAutocomplete.current.off("open", onOpen);
        geocoderAutocomplete.current.off("request_start", onRequestStart);
        geocoderAutocomplete.current.off("request_end", onRequestEnd);
        geocoderAutocomplete.current.off("places", onPlacesByCategoryChange);
        geocoderAutocomplete.current.off("places_request_start", onPlacesByCategoryRequestStart);
        geocoderAutocomplete.current.off("places_request_end", onPlacesByCategoryRequestEnd);
        geocoderAutocomplete.current.off("place_details_request_start", onPlaceDetailsRequestStart);
        geocoderAutocomplete.current.off("place_details_request_end", onPlaceDetailsRequestEnd);
        geocoderAutocomplete.current.off("place_select", onPlaceByCategorySelect);
        geocoderAutocomplete.current.off("clear", onClear);
      }
    };
  }, []);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.setType(typeValue);
    }
  }, [typeValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.setLang(langValue);
    }
  }, [langValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current && positionValue) {
      console.warn("WARNING! Obsolete function called. The  'position' input has been deprecated, please use the new 'biasByLocation' input instead!");
      geocoderAutocomplete.current.addBiasByProximity(positionValue);
    }
  }, [positionValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current && countryCodesValue) {
      console.warn("WARNING! Obsolete function called. The  'countryCodes' input has been deprecated, please use the new 'filterByCountryCode' input instead!");
      geocoderAutocomplete.current.addFilterByCountry(countryCodesValue);
    }
  }, [countryCodesValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.setLimit(limitValue);
    }
  }, [limitValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.setValue(valueValue || "");
    }
  }, [valueValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.addFilterByCountry(filterByCountryCodeValue);
    }
  }, [filterByCountryCodeValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.addFilterByCircle(filterByCircleValue);
    }
  }, [filterByCircleValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.addFilterByRect(filterByRectValue);
    }
  }, [filterByRectValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.addFilterByPlace(filterByPlaceValue);
    }
  }, [filterByPlaceValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.addBiasByCountry(biasByCountryCodeValue);
    }
  }, [biasByCountryCodeValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.addBiasByCircle(biasByCircleValue);
    }
  }, [biasByCircleValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.addBiasByRect(biasByRectValue);
    }
  }, [biasByRectValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.addBiasByProximity(biasByProximityValue);
    }
  }, [biasByProximityValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.setPreprocessHook(preprocessHookValue);
    }
  }, [preprocessHookValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.setPostprocessHook(postprocessHookValue);
    }
  }, [postprocessHookValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current) {
      geocoderAutocomplete.current.setSuggestionsFilter(suggestionsFilterValue);
    }
  }, [suggestionsFilterValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current && sendGeocoderRequestFuncValue) {
      geocoderAutocomplete.current.setSendGeocoderRequestFunc(sendGeocoderRequestFuncValue);
    }
  }, [sendGeocoderRequestFuncValue]);
  useEffect(function () {
    if (geocoderAutocomplete.current && sendPlaceDetailsRequestFuncValue) {
      geocoderAutocomplete.current.setSendPlaceDetailsRequestFunc(sendPlaceDetailsRequestFuncValue);
    }
  }, [sendPlaceDetailsRequestFuncValue]);
  return React.createElement("div", {
    className: "geocoder-container",
    style: {
      position: "relative"
    },
    ref: function ref(el) {
      geocoderContainer = el;
    }
  });
};

export { GeoapifyApiKey, GeoapifyContext, GeoapifyGeocoderAutocomplete };
//# sourceMappingURL=index.modern.js.map
